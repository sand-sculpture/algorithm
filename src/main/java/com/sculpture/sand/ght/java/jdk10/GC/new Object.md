对象创建
1、new 对象过程：
（1）检查指令参数（new 语句），能否在常量池中找到他的符号引用；
（2）如果存在，检查符号引用代表的类是否被加载、解析、初始化过；
（3）加载通过后虚拟机将为新生对象分配内存（所需内存大小在类加载完后便可确定）

2、内存分配方式：
指针碰撞：假设java堆内存中分配的是绝对规整的（一边是使用的，另外一边是未分配的，中间的指针是作为分界点的指示器）分配内存的动作是将指针完未分配区域移动一段与对象大小相等的距离，这种分配方式就叫指针碰撞；
空闲列表：如果堆内存并不是规整的，已使用和未分配的内存空间相互交错，这样空间碎片极多的情况就无法使用指针碰撞。虚拟机需要维护一个列表用于可用空间的地址，并在分配的时候实时更新到记录表上，这种分配方式成为空闲列表。
    具体使用哪种分配方式是由Java堆来决定，而java堆空间是否规整由GC决定，所以使用Serial、ParNew等多算法组合GC使用一般是指针碰撞，而是用CMS基于Mark-Sweep算法收集是通常采用空闲列表，在多线程分配内存的时候为了保
证线程的安全性JVM采用CAS配上失败重试机制保证更新原子性（分配内存同步处理）、JVM会为每个线程再JVM堆中预先分配一小块内存（本地线程分配缓冲），即分配内存动作在不同空间中进行

3、对象的内存布局：
对象内存布局大致分为三个区域：对象头（对象自身的运行时数据：哈希码，GC分代年龄、锁等等，类型指针：对象指向其他类元数据的指针JVM因此来确认该对象属于哪个实例）、实例数据（对象有效信息：类型，字段内容等等）、对齐填充（占位符，不一定存在）

4、对象访问定位：
1.句柄访问：Java堆中划分出来一块内存作为句柄池，reference中（Java栈中）存放就是对象句柄地址，句柄中包含了对象的实例数据与类型数据各自的具体地址信息。句柄地址是稳定的，在对象被移动时只会改变句柄中实例诗句指针，而引用本身不需要修改。
2.指针访问：这种方式JVM栈中帧栈的本地变量表所存储的应用地址就是实例数据的地址，可以直接引用。 引用所指向的对象中对象数据包括两部分，对象实例本身，对象类型在方法区中的地址。
