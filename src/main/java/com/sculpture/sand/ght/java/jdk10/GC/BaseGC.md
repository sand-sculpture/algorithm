##JVM 内存划分（JVM栈，本地方法栈，程序计数器，方法区，堆）
 ###JVM栈
线程私有，生命周期与线程共生死。方法执行时创建的内存模型即在执行时创建一个帧栈用于保存局部变量、操作数栈、动态链接、方法出口等等。
###本地方法栈
与JVM栈相似，但是实际上是服务于虚拟机的native方法
###Java堆
虚拟机启动时分配并占用大部分内存，线程共享。其中堆内存在分为Eden区，新生代，老年代。
Eden区：负责收容新生对象，但是若是创建时需要较大内存则会被直接交给老年代进行分配内存；
新生代：新生代内部会创建两个大小相同的Survivor区（from,to），Eden创建对象后经过一次Minor GC后就会被转移到某一个Survivor区，新生代使用复制算法来不断在两个Survivor区不断转移对象，直到被转移至老年代。
老年代：老年代会存放两种对象：
1、创建时过大的对象会直接被分配到老年代
2、新生代经过可控次数（默认16次）转移后的对象会被下放到老年代
老年代的内存不足时使用Full GC(标记-清除)来进行内存回收。
 ###方法区（永久代）
和堆一样线程共享，用来存放已经被JVM加载类的信息、常量、静态变量、即编译候的代码等数据。（1.7以前常量池放在方法区、1.7将常量池放在堆栈、1.8取消了方法区使用本地内存来存储元数据称之为元空间）
###程序计数器
占用很小一部分内存，主要用于记录当前线程正在执行的字节码行号，字节码解释器通过改变这个值来读句下一条该被执行的字节码指令，由于JVM多线程是由线程切换并分配处理器执行时间来实现的，所以在同一个时刻处理器只能处理
一条指令，所以在不断切换线程的指令时需要一个线程私有的计数器在切换后来找到正在执行以及该线程下一条指令。
如果执行的是java方法则程序计数器记录正在正在执行虚拟机字节码指令的地址、如果是是native方法则记录为空。



##回收算法：
###1、引用计数法：
    给每个创建出来的对象增加一个引用计数器，有新引用时+1，当引用失效是-1，当GC是如果是引用计数器为0则被回收掉，这个回收机制速度快，判断效率高，但是对于循环引用无法做到判断会产生内存堆积导致内存不足。
    例子：
        Object a = new Object();
        Object b = new Object();
        a = b;
        b= a;
        a = b = null;     //无法GC a,b

###2、可达性分析算法：
   通过一组GC Root作为起点，从这些起点向下进行搜索，向下搜索的路径称为引用链，对于没有引用链的GC Root对象称为不可用。
   GC Root判定：
        1.虚拟机栈（栈帧中本地变量表）引用的对象    --> new 出来的对象
        2.方法区中静态引用变量                    --> static
        3.方法区中常量应用变量                    --> 方法或者类中定义的变量
        4.本地方法栈（Native方法）中JNI引用对象
缺点：实现复杂，大量引用链分析会消耗大量的时间，且分析引用是否有效时会stw,所以会增加程序卡顿时间

##引用分析： (强引用-->软引用-->弱引用-->虚引用)
###1.强引用：
    代码中直接赋值引用，Object test = new Object(); String str = "hello"; 强应用若是还在永远不会被GC，即使内存不足只会抛出内存溢出错误也不会回收。

###2.软引用：
    用来描述一些有用但不是必须的引用，使用关键词“SoftReference”，该引用在内存不足时进行GC，用来解决网页缓存和图片缓存，现在基本不再使用。
    SoftReference<String> sr = new SoftReference<String>(new String("hello"));

###3.弱引用:
    用来描述非必须对象， 无论内存是否充足，GC时都会被回收，
    WeakReference<String> sr = new WeakReference<String>(new String("hello"));

###4.虚引用:
    如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收,虚引用必须和引用队列关联使用.
    ReferenceQueue<String> queue = new ReferenceQueue<String>();
    PhantomReference<String> pr = new PhantomReference<String>(new String("hello"), queue);


##判断对象是否还生存：
  判断对象是否死亡至少需要两次标记。
1.第一次标记：通过可达性算法来标记没有引用链的GC Root。筛选条件判断该对象是否有比较执行finalize()方法，当对象没有复写finalize()方法或者finalize()方法已经被JVM执行过则会被认为可回收对象。如果对象有必要执行finalize()方法则会被放到F-Queue队列中。
2.第二次标记：GC对F-Queue队列里的对象进行二次标记，如果对象在finalize()方法中重新与引用链上任何一个对象建立关系那么二次标记就会将该对象移除回收集合。
二次标记后F-queue队列里对象将被回收。

PS：
   finalize，Object定义的方法，只能被调用一次，在对象将要被GC时调用， 可以通过复写finalize()方法使得该对象重新引用到GCRoot引用链上逃出GC（例如将该对象用this方式赋值给某个对象变量或者成员变量），但是假如当finalize()方法已经执行但是现在内存又再次
充足不用再进行回收所以该对象已经执行过了finalize方法，后续GC的时候不会再进行执行，所以使用finalize()方法并不一定会保证回收，实际上好像并没有特别可靠的用处。

##回收方法区：
    永久代（方法区） 垃圾回收主要包括废弃常量以及无用类，回收废弃常量类似于堆内存回收，例如String,当字符串“abc”在常量池中没有任何引用如果这时发生GC这该字符串常量会被回收内存；判定无用的类必须同时满足下面所有条件：
   1、该类所有实例均被回收即堆内存中没有该类的任何对象实例；
   2、加载该类的ClassLoader已经被回收；
   3、该类没有在任何地方被引用到，通过反射也无法找到任何引用者；
   虚拟机对于满足这三个条件的类可以进行回收但不是必须回收，主要取决于JVM虚拟机启动参数（-Xnoclassgc）控制. (-Xnoclassgc-->关闭虚拟机对class的垃圾回收功能。)




