
##1、Serial收集器
     单线程收集器，再进行GC时会暂停其他所有工作线程直到手机结束。造成效果就是如果内存较小会频繁GC且在GC的时候会造成程序卡顿。适用于client模式下的JVM，该模式下更注重速度（编译，启动）。在进行GC的时候新生代
采用负责算法，年老代使用标记整理算法进行回收。

##2、ParNew收集器
     多线程版本的Serial收集器，该收集器在默认启东时会开启CPU核数相同的线程。多线程GC可以提高处理速度速度，缩减程序工作线程卡顿时间

##3、Parallel Scavenge收集器
     该收集器是适用于新生代收集器，使用复制算法。与ParNew收集器以减少卡顿时间为目的不同，Parallel Scavenge收集器更注重吞吐量的控制，在启动时可以控制多个收集器性能参数，例如：
     -XX：MAXGCPauseMills 最大垃圾收集停顿时间
     -XX：GCTimeRatio 最大吞吐量
     -Xmn：新生代大小
     -XX：SuvivorRatio Eden与Ser
     -XX：PretenureSizeThreshold 晋升老年代对象大小
     等等

##4、Serial Old 收集器
   Serial收集器的老年版本，标记整理算法GC。

##5、Parallel Old 收集器
   Parallel Scavenge收集器老年版本，JDK1.6才开始加入，多线程版本标记整理。

##6、CMS收集器
   目的最大程度缩短收集器执行造成卡顿时间，基于标记清除算法，执行GC步骤：初始标记（标记GC Root可以直接关联的对象）-->并发标记（GC Root Tracing）-->重新标记(修整并发标记期间因为继续操作而露的被回收的对象，查漏补缺)->并发删除（标记完成统一删除）。
   （初始标记与重新标记需要Stop All World ，其中重新标记时间比初始标记长，并发标记时间短）
   缺点：
   1、并发标记虽然不会占用工作线程时间，但是在并发执行会消耗掉很多内存，所以还是会对系统产生一定的性能影响。
   2、无法处理浮动垃圾，浮动垃圾产生是因为在并发清除的时候没有暂停工作线程所以在清除的同时还是会产生新垃圾，这部分出现在该次标记之后所以无法处理。
   3、标记清除算法会导致大量的内存水碎片当没有连续的大空间来支持分配的时候会触发提前触发Full FC。

##7、G1收集器
  优点：
  1、并行与并发：充分利用多CPU以及多核环境优势。使用多个CPU来缩短stop-the-word停顿时间，部分收集器原本需要停顿Java线程来执行GC动作G1收集器可以通过并发方式让Java程序继续运行。
  2、分代收集：管理整个Java堆，采用不同方式去处理创建的新对象和已经存活一段时间熬过多次GC的旧对象。
  3、空间整合：G1运行不会产生空间碎片。
  4、可预测的停顿：除了减少停顿时间还会建立可预测停顿时间模型，能让明确一个长度为M毫秒的时间内消耗在垃圾收集上的时间不能超过N毫秒。

执行GC顺序 初始标记-->并发标记-->最终标记（其他和CMS相似增加合并Remembered Log 到Remembered Set中）-->筛选回收（根据回收价值和成本指定进行排序指定计划并整理内存空间）


G1 和 CMS 不同点
1.使用范围：CMS是老年代收集器，会配合Serial或者ParNew收集器一起使用；G1收集器范围老年代和新生代，不需要配合其他收集器使用
2.STW时间：CMS以最小停顿时间为目标，所以在初始标记和重复标记阶段stw时间会非常短，但是可能会频繁触发FULL GC； G1可以预测停顿时间建立stw时间模型
3.垃圾碎片：CMS使用标记-清除算法所以会产生很多空间碎片；G1使用标记-整理算法，在GC时会不断整理空间，所以触发FULL GC频率低。
4.回收过程：。


    





















   GC ROOT

