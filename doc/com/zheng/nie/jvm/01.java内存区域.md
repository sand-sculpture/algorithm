#####java内存分布
    1.程序计数器
        1.线程私有，多线程切换的时候保证线程能够回到当时执行的地方，没有outofmemoryerror的区域。
    2.java虚拟机栈
        1.线程私有，生命周期和线程相同，每个方法在执行的同时会生成一个栈帧，存储局部变量表，操作数栈，动态链接，方法出口等信息。
            每个方法从调用到被执行完的过程，对应一个栈帧在虚拟机中从入栈到出栈的过程。
            局部变量表：编译期可知的各种基本数据类型，对象引用
        2.异常情况
            如果线程请求的深度大于虚拟机允许的深度，将抛出StackOverflowError,如果虚拟机栈可以动态扩展
             如果扩展时无法申请足够的内存，就会抛出OutOfMemoryError异常。
    3.本地方法栈
        与虚拟机栈相似，不过在于虚拟机栈执行的是java方法，本地方法栈执行的是Native服务，本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。
    4.java堆
        1.线程共享，存放对象实例，
        2.堆细分
            1.新生代
                Eden区
                From Survivor
                To Survivor
            2.老年代
        3.如果堆中没有内存完成实例分配，切堆无法扩展的时候，将抛出OutOfMemroyError
    5.方法区
        线程共享区域，存储已被虚拟机加载的类信息，常量，静态变量，
    6.运行时常量池
        方法区的一部分，存放编译期间生成的各种字面量和符号引用，
    7.直接内存
#####对象创建过程
    当虚拟机遇到new指令时
    1.判断是否能在常量池中定位到一个类的符号引用，并且检查类是否被加载、解析、和初始化过，如果没有先进性类的加载。
    2.类加载检查通过后，虚拟机为新生对象分配内存。
#####对象头内存分布
    对象头包括两部分信息
        1.存储对象自身运行时数据
            HashCode、GC分代年龄、锁状态、线程持有的锁、偏向线程ID
        2.类型指针
            对象指向类元数据的指针，虚拟机通过这个指针确定这个对象是哪个类的实例。
#####对象的访问定位
    1.通过栈的引用来访问，栈中只规定了虚拟机的引用，并没有定义这个引用应该通过何种方式去定位，
    2.对象访问的两种方式
        1.句柄
            java堆中会划分出一块内存来作为句柄池，栈的引用中存储的就是句柄池中的地址，句柄中包含了对象实例数据和数据类型的具体地址，。
        2.直接指针 
            如果使用指针访问，栈中的引用存储的就是对象的地址，  堆中的对象存储改对象的对象类型数据。 
    3.句柄VS直接指针
        句柄的好处是，引用中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针
        直接指针最大的好处是速度快，节省了一次指针定位的时间开销
           
#####导致OutOfMemoryError异常的常见原因有以下几种：
    1.内存中加载的数据量过于庞大，如一次从数据库取出过多数据；
    2.集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；
    3.代码中存在死循环或循环产生过多重复的对象实体；
    4.使用的第三方软件中的BUG；
    5.启动参数内存值设定的过小；        