#####1.哪些内存需要回收？
    程序计数器、虚拟机栈、本地方法栈、三个区域随着随线程而生，随线程而灭。这几个区域不
    需要过多考虑回收的问题，堆中的对象大多数运行时创建的，这部分内存的分配和回收都是动态的。
#####2.如何判断对象已死
    2.1 引用计数法
        给一个对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就+1，当引用失效时，计数器就-1；
        何时候计数器为0的对象就是不可能再被使用的，
        缺点：很难解决对象之间循环依赖的情况。
    2.2 可达性分析算法
        通过一系列称为GC ROOTS的对象作为起点，从这些节点往下搜索，搜索走过的路径称为引用链，
        当一个对象到GC ROOTS没有任何引用连相连接的话，则这个对象不可达
        GC ROOTS对象定义：
                虚拟机栈(栈帧中的本地变量表)中引用的对象。
                方法区中类静态属性引用的对象
                方法区中常量引用的对象
                本地方法栈中引用的对象
#####3.引用分类
    3.1 强引用
        代码中普遍存在，Object obj = new Object(),这类引用，只要强引用存在，垃圾收集器永远不会回收
    3.2 软引用
        还有用但是非必须的对象，在系统要发出内存溢出异常之前，会把这些对象列入回收对象只中进行第二次回收。
    3.3 弱引用
        强度比软引用更弱一些，被弱引用引用的对象只能存活在下一次垃圾收集发生之前。
    3.4 虚引用
        也叫幽灵引用或者幻影引用，无法通过虚引用获取一个对象的实例，为一个对象设置虚引用关联的唯一目的
        就是能在这个对象被回收的时候收到一个系统通知。
#####4.对象回收
    如果一个对象在可达性分析之后，没有引用链，那么这和对象将会被进行第一次标记并且尽心筛选，
    筛选的条件是此对象是否有必要执行finalize()方法
#####5.垃圾回收算法
    5.1.标记-清除算法
        过程：分为标记和清除两个阶段，首先标记出所有需要回收的对象，在标记完成后统一进行回收所有被标记的对象，
        缺点：1.标记和清除的效率都不高，2.清除之后会产生大量不连续的碎片，空间锁片太多会导致以后程序在运行过程中需要分配较大对象时，
            无法找到足够的连续内存而不得提前触发另一次垃圾收集动作
    5.2.复制算法
        过程：将内存按照容量分为大小相等的两部分，每次只使用其中一部分，当进行垃圾回收的时候，
        将正在使用的呢部分内存中还存活的对象复制到另一块没有使用的内存之中，然后将使用过的内存进行清除，
        只需移动指针按照顺序分配即可。
        优点：实现简单，运行高效。
        缺点：将使用的内存缩小为原来的一半。   
    5.3.标记整理算法
        过程：标记需要回收的对象，然后存活的对象向一端移动，然后清除端边界以外的内存。
    5.4.分代收集
        将java堆分为新生代和老生代，新生代每次垃圾收集都会有大批量对象死亡，只有少量对象存活，可以选择复制算法，
        只需付出少量存活对象的复制成本就可以完成收集。
        老年代中对象存活率高，没有额外空间对他进行分配担保，就必须使用标记清除或标记整理算法，当老年代容量满的时候，会进行一次FULL GC
#####6.垃圾回收器
    1 Serial收集器
        收集过程：这个收集器是一个单线程收集器，单线程的理解不是只是用一个CPU或一条收集线程去完成垃圾收集工作，
                更重要的是他在垃圾收集的过程中必须暂停其他工作的线程。直到他收集结束,stop the world。
        缺点：必须暂停其他线程
        优点：简单高效
    2.1 ParNew收集器
        1.是Serial垃圾收集器的多线程版本，除了使用多线程进行垃圾收集之外，其他类似。
        2.目前只有parNew收集器和CMS能组合收集
        3.ParNew在CPU的情况下不会有比Serial收集器更好的效果

####7.CMS收集器(Current Mark Sweep)
    1.这款收集器是真正意义上的并发收集器，第一次让垃圾收集线程和用户线程（几乎）同时工作。
    2.是一种以获取最短回收停顿时间为目标的收集器
    3.分为四个步骤
        3.1初始标记:仅仅只是标记一下GC Root能直接关联到的对象，速度很快，并发标记阶段就是
        3.2并发标记
        3.3重新标记
        3.4并发清除
        其中初始标记和重新标记都需要 stop the world 
    
####8.Parallel Scavenge收集器
    1.新生代收集器，使用复制算法。并行的多线程收集器
    2.Parallel Scavenge 与其他收集器的关注点不同，
        CMS等收集器关注点是尽可能的缩短垃圾收集时用户线程的停顿时间 Parallel Scavenge 收集器的目标是达成一个可控制的吞吐量。
        吞吐量 = CPU运行用户代码的时间/CPU总消耗时间的比值。
####9.Serial Old收集器
    Serial Old是Serial收集器的老年代版本，单线程收集器，使用标记整理算法     
####10.Paraller Old收集器
    Parallel Scavenge 收集器的老年代版本，使用多线程和标记整理算法
####G1收集器
    1.并行与并发：G1能充分利用多CPU，多核环境下的硬件优势,使用多个CPU来缩短
        Stop-The-world停顿的时间
    2.分代收集：G1不需要其他收集器配合就能独立管理整个GC堆。
    3.空间整合：G1运作期间不会产生内存碎片，收集后能提供规整的可用内存。
    4.可预测的停顿
####对象的分配情况
    1.大多数情况下，对象在新生代Eden中分配，当Eden中没有足够的空间进行分配是，虚拟机将发起一次MinorGc
###大对象直接进入老年代
    1.所谓的大对象是指，需要大量连续内存空间的java对象(字符串以及数组)
    2.-XX:PretenureSizeThresshold参数，令大于这个设置值的对象能直接在老年代分配，这样做的目的是避免
       在Eden区以及两个Survivor区之间发生大量的内存复制
####长期存活的对象将进入老年代
    1.虚拟机个每个对象定义了一个年龄计数器，如果对象在Eden出生并经过第一次Minor 
    GC后仍然存活，并且能被Survivor容纳的话，将被移动代Survivor空间中，并且对象的
    年龄设为1，对象在Survior中每熬过一次Minor Gc 年龄就增加1岁，当他年龄增加到一定程度（15）
    就会被晋升到老年代中。
#####动态对象年龄判定
    如果在Survivor空间中相同年龄所有对象的大小总和大于Survior空间的一半，
    年龄大于或等于该年龄的对象就可以直接进入老年代
####空间分配担保
    再Minor GC 发生之前虚拟机首先会检查
        1.老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立
            那么可以确保Minor GC是确保安全的，如果不成立
        2.虚拟机查看HandlePromotionFaliure设置值是否允许担保失败，如果允许
            继续检查老年代的最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于
            尝试进行一次啊Mnor GC 尽管这次有风险，如果小于，或者
            HandlePromotionFailure设置不允许冒险，那么这次也要改成进行一次Full GC
    
    
    
    
        
            
        
   