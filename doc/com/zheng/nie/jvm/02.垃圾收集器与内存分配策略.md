#####1.哪些内存需要回收？
    程序计数器、虚拟机栈、本地方法栈、三个区域随着随线程而生，随线程而灭。这几个区域不
    需要过多考虑回收的问题，堆中的对象大多数运行时创建的，这部分内存的分配和回收都是动态的。
#####4.如何判断对象已死
    4.1 引用计数法
        给一个对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就+1，当引用失效时，计数器就-1；
        何时候计数器为0的对象就是不可能再被使用的，
        缺点：很难解决对象之间循环依赖的情况。
    4.2 可达性分析算法
        通过一系列称为GC ROOTS的对象作为起点，从这些节点往下搜索，搜索走过的路径称为引用链，
        当一个对象到GC ROOTS没有任何引用连相连接的话，则这个对象不可达
        GC ROOTS对象定义：
                虚拟机栈(栈帧中的本地变量表)中引用的对象。
                方法区中类静态属性引用的对象
                方法区中常量引用的对象
                本地方法栈中引用的对象
#####5.引用分类
    5.1 强引用
        代码中普遍存在，Object obj = new Object(),这类引用，只要强引用存在，垃圾收集器永远不会回收
    5.2 软引用
        还有用但是非必须的对象，在系统要发出内存溢出异常之前，会把这些对象列入回收对象只中进行第二次回收。
    5.3 弱引用
        强度比软引用更弱一些，被弱引用引用的对象只能存活在下一次垃圾收集发生之前。
    5.4 虚引用
        也叫幽灵引用或者幻影引用，无法通过虚引用获取一个对象的实例，为一个对象设置虚引用关联的唯一目的
        就是能在这个对象被回收的时候收到一个系统通知。
#####6.对象回收
    如果一个对象在可达性分析之后，没有引用链，那么这和对象将会被进行第一次标记并且尽心筛选，
    筛选的条件是此对象是否有必要执行finalize()方法
#####7.垃圾回收算法
    1.标记-清除算法
        过程：分为标记和清除两个阶段，首先标记出所有需要回收的算法，在标记完成后统一进行回收所有被标记的对象，
        缺点：1.标记和清除的效率都不高，2.清除之后会产生大量不连续的碎片，空间锁片太多会导致以后程序在运行过程中需要分配较大对象时，
            无法找到足够的连续内存而不得提前触发另一次垃圾收集动作
    2.复制算法
        过程：将内存按照容量分为大小相等的两部分，每次只使用其中一部分，当进行垃圾回收的时候，
        将正在使用的呢部分内存中还存活的对象复制到另一块没有使用的内存之中，然后将使用过的内存进行清除，
        只需移动指针按照顺序分配即可。
        优点：实现简单，运行高效。
        缺点：将使用的内存缩小为原来的一半。   
            
        
   